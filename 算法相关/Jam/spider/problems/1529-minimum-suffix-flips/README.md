# [Minimum Suffix Flips][title]

## Description

给你一个长度为 `n` 、下标从 **0** 开始的二进制字符串 `target` 。你自己有另一个长度为 `n` 的二进制字符串 `s`
，最初每一位上都是 0 。你想要让 `s` 和 `target` 相等。

在一步操作，你可以选择下标 `i`（`0 <= i < n`）并翻转在 **闭区间** `[i, n - 1]` 内的所有位。翻转意味着 `'0'` 变为
`'1'` ，而 `'1'` 变为 `'0'` 。

返回使 __`s` __ 与 __`target` 相等需要的最少翻转次数。



**示例 1：**
            **输入：** target = "10111"    **输出：** 3    **解释：** 最初，s = "00000" 。    选择下标 i = 2: "00 _ **000**_ " -> "00 _ **111**_ "    选择下标 i = 0: " _ **00111**_ " -> " _ **11000**_ "    选择下标 i = 1: "1 _ **1000**_ " -> "1 _ **0111**_ "    要达成目标，需要至少 3 次翻转。    

**示例 2：**
            **输入：** target = "101"    **输出：** 3    **解释：** 最初，s = "000" 。    选择下标 i = 0: " _ **000**_ " -> " _ **111**_ "    选择下标 i = 1: "1 _ **11**_ " -> "1 _ **00**_ "    选择下标 i = 2: "10 _ **0**_ " -> "10 _ **1**_ "    要达成目标，需要至少 3 次翻转。    

**示例 3：**
            **输入：** target = "00000"    **输出：** 0    **解释：** 由于 s 已经等于目标，所以不需要任何操作    



**提示：**

  * `n == target.length`
  * `1 <= n <= 105`
  * `target[i]` 为 `'0'` 或 `'1'`


**Tags:** Greedy, String

**Difficulty:** Medium

## 思路

[title]: https://leetcode-cn.com/problems/minimum-suffix-flips
