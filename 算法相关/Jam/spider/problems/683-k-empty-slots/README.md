# [K Empty Slots][title]

## Description

`n` 个灯泡排成一行，编号从 `1` 到 `n` 。最初，所有灯泡都关闭。每天  **只打开一个**  灯泡，直到 `n` 天后所有灯泡都打开。

给你一个长度为 `n` 的灯泡数组 `blubs` ，其中 `bulls[i] = x` 意味着在第 `(i+1)` 天，我们会把在位置 `x`
的灯泡打开，其中 `i` **从 0 开始** ，`x` **从 1 开始** 。

给你一个整数 `k` ，请返回 _恰好有两个打开的灯泡，且它们中间 **正好** 有 `k` 个  **全部关闭的** 灯泡的 **最小的天数** _。
_如果不存在这种情况，返回`-1` 。_



**示例 1：**
            **输入：**    bulbs = [1,3,2]，k = 1    **输出：** 2    **解释：**    第一天 bulbs[0] = 1，打开第一个灯泡 [1,0,0]    第二天 bulbs[1] = 3，打开第三个灯泡 [1,0,1]    第三天 bulbs[2] = 2，打开第二个灯泡 [1,1,1]    返回2，因为在第二天，两个打开的灯泡之间恰好有一个关闭的灯泡。    

**示例 2：**
            **输入：** bulbs = [1,2,3]，k = 1    **输出：** -1    



**提示：**

  * `n == bulbs.length`
  * `1 <= n <= 2 * 104`
  * `1 <= bulbs[i] <= n`
  * `bulbs` 是一个由从 `1` 到 `n` 的数字构成的排列
  * `0 <= k <= 2 * 104`


**Tags:** Binary Indexed Tree, Array, Ordered Set, Sliding Window

**Difficulty:** Hard

## 思路

[title]: https://leetcode-cn.com/problems/k-empty-slots
